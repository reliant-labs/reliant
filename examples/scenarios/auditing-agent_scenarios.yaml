# Scenario tests for auditing-agent workflow
#
# This workflow has a loop (audited_loop) with nodes:
#   main_agent -> audit_check -> execute_audit -> save_approved_response (if approved) -> execute_tools (if has tools) -> compact
#                              \-> (if no tool calls from audit_check) save_approved_response
#
# Key behaviors:
# - execute_audit has inline save_message that saves guidance when provided (regardless of approval)
# - When denied, workflow stops after execute_audit (no save_approved_response or execute_tools)
# - execute_tools only runs when main_agent has tool_calls and audit is approved
# - Loop continues while tool_calls is not empty and iteration < max_turns

---
# Happy path: Agent responds with text only, no tool calls, loop exits after first iteration
name: text_only_response
description: Agent responds with just text, no tool calls - loop exits immediately
events:
  # main_agent responds with text only
  - node: audited_loop.main_agent
    output:
      message:
        role: assistant
        text: "I can help you with that. Here's my answer."
      response_text: "I can help you with that. Here's my answer."
      tool_calls: []
  # audit_check responds with approval via response tool
  - node: audited_loop.audit_check
    output:
      message:
        role: assistant
        text: ""
      response_text: ""
      tool_calls:
        - id: call_0
          name: audit
          input:
            approved: true
            guidance: ""
  # execute_audit tool result
  - node: audited_loop.execute_audit
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_0
          content: '{"approved": true}'
      response_data:
        audit:
          approved: true
          guidance: ""
      thread_token_count: 500
expect:
  outcome: completed
  reached:
    - audited_loop
    - audited_loop.main_agent
    - audited_loop.audit_check
    - audited_loop.execute_audit
    - audited_loop.save_approved_response
  not_reached:
    - audited_loop.execute_tools  # No tool calls, so execute_tools should be skipped

---
# Agent with tool calls that get audited and approved
name: tool_calls_approved
description: Agent makes tool calls, auditor approves, tools execute
events:
  # First iteration: main_agent requests a tool
  - node: audited_loop.main_agent
    output:
      message:
        role: assistant
        text: "Let me read that file for you."
      response_text: "Let me read that file for you."
      tool_calls:
        - id: call_0
          name: view
          input:
            file_path: "/path/to/file.go"
  # audit_check approves
  - node: audited_loop.audit_check
    output:
      message:
        role: assistant
        text: ""
      response_text: ""
      tool_calls:
        - id: call_1
          name: audit
          input:
            approved: true
            guidance: ""
  # execute_audit result
  - node: audited_loop.execute_audit
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_1
          content: '{"approved": true}'
      response_data:
        audit:
          approved: true
          guidance: ""
      thread_token_count: 500
  # execute_tools result
  - node: audited_loop.execute_tools
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_0
          content: "package main\n\nfunc main() {}"
      thread_token_count: 600
  # Second iteration: main_agent responds with final answer
  - node: audited_loop.main_agent
    output:
      message:
        role: assistant
        text: "The file contains a simple Go main package."
      response_text: "The file contains a simple Go main package."
      tool_calls: []
  # audit_check for second iteration
  - node: audited_loop.audit_check
    output:
      message:
        role: assistant
        text: ""
      response_text: ""
      tool_calls:
        - id: call_2
          name: audit
          input:
            approved: true
            guidance: ""
  - node: audited_loop.execute_audit
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_2
          content: '{"approved": true}'
      response_data:
        audit:
          approved: true
          guidance: ""
      thread_token_count: 500
expect:
  outcome: completed
  reached:
    - audited_loop
    - audited_loop.main_agent
    - audited_loop.audit_check
    - audited_loop.execute_audit
    - audited_loop.save_approved_response
    - audited_loop.execute_tools

---
# Audit rejection flow - auditor rejects and provides guidance, agent adjusts
name: audit_rejected_with_guidance
description: Auditor rejects agent's approach, guidance message is saved, agent adjusts on next iteration
events:
  # Iteration 1: main_agent wants to do something risky
  - node: audited_loop.main_agent
    output:
      message:
        role: assistant
        text: "I'm going to delete all the test files."
      response_text: "I'm going to delete all the test files."
      tool_calls:
        - id: call_0
          name: bash
          input:
            command: "rm -rf tests/"
  # audit_check rejects
  - node: audited_loop.audit_check
    output:
      message:
        role: assistant
        text: ""
      response_text: ""
      tool_calls:
        - id: call_1
          name: audit
          input:
            approved: false
            guidance: "Do not delete test files. Please suggest an alternative approach."
  # execute_audit result with rejection
  - node: audited_loop.execute_audit
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_1
          content: '{"approved": false, "guidance": "Do not delete test files."}'
      response_data:
        audit:
          approved: false
          guidance: "Do not delete test files. Please suggest an alternative approach."
      thread_token_count: 500
  # Guidance is saved - loop continues because main_agent had tool_calls
  # (outputs.tool_calls from inline workflow outputs section)

  # Iteration 2: main_agent adjusts approach based on guidance
  - node: audited_loop.main_agent
    output:
      message:
        role: assistant
        text: "I understand. Instead of deleting tests, I'll help you organize them."
      response_text: "I understand. Instead of deleting tests, I'll help you organize them."
      tool_calls: []
  # audit_check for adjusted response
  - node: audited_loop.audit_check
    output:
      message:
        role: assistant
        text: ""
      response_text: ""
      tool_calls:
        - id: call_2
          name: audit
          input:
            approved: true
            guidance: ""
  - node: audited_loop.execute_audit
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_2
          content: '{"approved": true}'
      response_data:
        audit:
          approved: true
          guidance: ""
      thread_token_count: 600
  # Loop exits because tool_calls is now empty
expect:
  outcome: completed
  reached:
    - audited_loop
    - audited_loop.main_agent
    - audited_loop.audit_check
    - audited_loop.execute_audit  # Guidance saved inline on first iteration (denied)
    - audited_loop.save_approved_response  # Reached on second iteration (approved)

---
# Approved with guidance - auditor approves but provides feedback
name: approved_with_guidance
description: Auditor approves the action but provides helpful guidance that should be saved to thread
events:
  # main_agent makes a tool call
  - node: audited_loop.main_agent
    output:
      message:
        role: assistant
        text: "Let me search for that pattern."
      response_text: "Let me search for that pattern."
      tool_calls:
        - id: call_0
          name: grep
          input:
            pattern: "TODO"
            path: "."
  # audit_check approves BUT provides guidance
  - node: audited_loop.audit_check
    output:
      message:
        role: assistant
        text: ""
      response_text: ""
      tool_calls:
        - id: call_1
          name: audit
          input:
            approved: true
            guidance: "Consider limiting search scope to specific directories to avoid slow performance."
  # execute_audit result with approval AND guidance
  - node: audited_loop.execute_audit
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_1
          content: '{"approved": true, "guidance": "Consider limiting search scope to specific directories."}'
      response_data:
        audit:
          approved: true
          guidance: "Consider limiting search scope to specific directories to avoid slow performance."
      thread_token_count: 500
  # execute_tools result
  - node: audited_loop.execute_tools
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_0
          content: '["main.go:10", "util.go:25"]'
      thread_token_count: 600
  # Second iteration: main_agent responds with final answer
  - node: audited_loop.main_agent
    output:
      message:
        role: assistant
        text: "Found 2 TODOs in the codebase."
      response_text: "Found 2 TODOs in the codebase."
      tool_calls: []
  # audit_check approves final response (no guidance this time)
  - node: audited_loop.audit_check
    output:
      message:
        role: assistant
        text: ""
      response_text: ""
      tool_calls:
        - id: call_2
          name: audit
          input:
            approved: true
            guidance: ""
  - node: audited_loop.execute_audit
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_2
          content: '{"approved": true}'
      response_data:
        audit:
          approved: true
          guidance: ""
      thread_token_count: 500
expect:
  outcome: completed
  reached:
    - audited_loop
    - audited_loop.main_agent
    - audited_loop.audit_check
    - audited_loop.execute_audit  # Guidance saved inline via save_message condition
    - audited_loop.save_approved_response
    - audited_loop.execute_tools

---
# Audit check without tool calls - goes directly to save_approved_response
name: audit_no_response_tool
description: Audit check responds without calling the audit tool
events:
  - node: audited_loop.main_agent
    output:
      message:
        role: assistant
        text: "Here's my analysis."
      response_text: "Here's my analysis."
      tool_calls: []
  # audit_check responds with text only (no tool call)
  - node: audited_loop.audit_check
    output:
      message:
        role: assistant
        text: "Looks good to me."
      response_text: "Looks good to me."
      tool_calls: []
expect:
  outcome: completed
  reached:
    - audited_loop
    - audited_loop.main_agent
    - audited_loop.audit_check
    - audited_loop.save_approved_response
  not_reached:
    - audited_loop.execute_audit

---
# Multiple tool calls in sequence
name: multiple_tool_iterations
description: Agent makes multiple tool calls across iterations
events:
  # Iteration 1: search for files
  - node: audited_loop.main_agent
    output:
      message:
        role: assistant
        text: "Let me search for relevant files."
      response_text: "Let me search for relevant files."
      tool_calls:
        - id: call_0
          name: grep
          input:
            pattern: "TODO"
            path: "."
  - node: audited_loop.audit_check
    output:
      message:
        role: assistant
        text: ""
      response_text: ""
      tool_calls:
        - id: call_1
          name: audit
          input:
            approved: true
            guidance: ""
  - node: audited_loop.execute_audit
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_1
          content: '{"approved": true}'
      response_data:
        audit:
          approved: true
          guidance: ""
      thread_token_count: 500
  - node: audited_loop.execute_tools
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_0
          content: '["main.go:10", "util.go:25"]'
      thread_token_count: 600
  # Iteration 2: read file
  - node: audited_loop.main_agent
    output:
      message:
        role: assistant
        text: "Found some TODOs. Let me check main.go."
      response_text: "Found some TODOs. Let me check main.go."
      tool_calls:
        - id: call_2
          name: view
          input:
            file_path: "main.go"
  - node: audited_loop.audit_check
    output:
      message:
        role: assistant
        text: ""
      response_text: ""
      tool_calls:
        - id: call_3
          name: audit
          input:
            approved: true
            guidance: ""
  - node: audited_loop.execute_audit
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_3
          content: '{"approved": true}'
      response_data:
        audit:
          approved: true
          guidance: ""
      thread_token_count: 500
  - node: audited_loop.execute_tools
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_2
          content: "// TODO: implement feature"
      thread_token_count: 700
  # Iteration 3: final response
  - node: audited_loop.main_agent
    output:
      message:
        role: assistant
        text: "Found 2 TODOs in the codebase."
      response_text: "Found 2 TODOs in the codebase."
      tool_calls: []
  - node: audited_loop.audit_check
    output:
      message:
        role: assistant
        text: ""
      response_text: ""
      tool_calls:
        - id: call_4
          name: audit
          input:
            approved: true
            guidance: ""
  - node: audited_loop.execute_audit
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_4
          content: '{"approved": true}'
      response_data:
        audit:
          approved: true
          guidance: ""
      thread_token_count: 500
expect:
  outcome: completed
  reached:
    - audited_loop
    - audited_loop.main_agent
    - audited_loop.audit_check
    - audited_loop.execute_audit
    - audited_loop.save_approved_response
    - audited_loop.execute_tools

---
# Max turns limit scenario - loop exits when iteration limit reached
name: max_turns_limit_reached
description: Loop exits when iter.iteration reaches inputs.agent.max_turns
inputs:
  agent:
    max_turns: 2
events:
  # Iteration 1: main_agent makes a tool call
  - node: audited_loop.main_agent
    output:
      message:
        role: assistant
        text: "Let me search for files."
      response_text: "Let me search for files."
      tool_calls:
        - id: call_0
          name: grep
          input:
            pattern: "TODO"
            path: "."
  - node: audited_loop.audit_check
    output:
      message:
        role: assistant
        text: ""
      response_text: ""
      tool_calls:
        - id: call_1
          name: audit
          input:
            approved: true
            guidance: ""
  - node: audited_loop.execute_audit
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_1
          content: '{"approved": true}'
      response_data:
        audit:
          approved: true
          guidance: ""
      thread_token_count: 500
  - node: audited_loop.execute_tools
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_0
          content: '["main.go:10"]'
      thread_token_count: 600
  # Iteration 2 (max_turns=2, so this is the last allowed iteration)
  - node: audited_loop.main_agent
    output:
      message:
        role: assistant
        text: "Found it. Let me read the file."
      response_text: "Found it. Let me read the file."
      tool_calls:
        - id: call_2
          name: view
          input:
            file_path: "main.go"
  - node: audited_loop.audit_check
    output:
      message:
        role: assistant
        text: ""
      response_text: ""
      tool_calls:
        - id: call_3
          name: audit
          input:
            approved: true
            guidance: ""
  - node: audited_loop.execute_audit
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_3
          content: '{"approved": true}'
      response_data:
        audit:
          approved: true
          guidance: ""
      thread_token_count: 500
  - node: audited_loop.execute_tools
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_2
          content: "package main"
      thread_token_count: 700
  # Loop exits after iteration 2 because iter.iteration (2) is no longer < max_turns (2)
expect:
  outcome: completed
  reached:
    - audited_loop
    - audited_loop.main_agent
    - audited_loop.audit_check
    - audited_loop.execute_audit
    - audited_loop.save_approved_response
    - audited_loop.execute_tools

---
# Compaction triggered when token count exceeds threshold
name: compaction_triggered
description: Token count exceeds compaction_threshold, compact node runs
inputs:
  agent:
    compaction_threshold: 1000
events:
  # main_agent requests a tool
  - node: audited_loop.main_agent
    output:
      message:
        role: assistant
        text: "Let me read that large file."
      response_text: "Let me read that large file."
      tool_calls:
        - id: call_0
          name: view
          input:
            file_path: "/path/to/large_file.go"
  # audit_check approves
  - node: audited_loop.audit_check
    output:
      message:
        role: assistant
        text: ""
      response_text: ""
      tool_calls:
        - id: call_1
          name: audit
          input:
            approved: true
            guidance: ""
  # execute_audit result
  - node: audited_loop.execute_audit
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_1
          content: '{"approved": true}'
      response_data:
        audit:
          approved: true
          guidance: ""
      thread_token_count: 500
  # execute_tools returns large result, token count exceeds threshold
  - node: audited_loop.execute_tools
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_0
          content: "Very long file content that causes context to grow..."
      thread_token_count: 5000
  # Compact runs because thread_token_count (5000) > compaction_threshold (1000)
  - node: audited_loop.compact
    output:
      message:
        role: assistant
        text: "Context compacted."
  # Next iteration: main_agent responds with final answer
  - node: audited_loop.main_agent
    output:
      message:
        role: assistant
        text: "The file contains Go code."
      response_text: "The file contains Go code."
      tool_calls: []
  # audit_check approves final response
  - node: audited_loop.audit_check
    output:
      message:
        role: assistant
        text: ""
      response_text: ""
      tool_calls:
        - id: call_2
          name: audit
          input:
            approved: true
            guidance: ""
  - node: audited_loop.execute_audit
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_2
          content: '{"approved": true}'
      response_data:
        audit:
          approved: true
          guidance: ""
      thread_token_count: 1500
expect:
  outcome: completed
  reached:
    - audited_loop
    - audited_loop.main_agent
    - audited_loop.audit_check
    - audited_loop.execute_audit
    - audited_loop.save_approved_response
    - audited_loop.execute_tools
    - audited_loop.compact

---
# Compaction skipped when token count is below threshold
name: compaction_skipped_below_threshold
description: Token count stays below compaction_threshold, compact node is not reached
inputs:
  agent:
    compaction_threshold: 185000
events:
  # main_agent requests a tool
  - node: audited_loop.main_agent
    output:
      message:
        role: assistant
        text: "Let me read that file."
      response_text: "Let me read that file."
      tool_calls:
        - id: call_0
          name: view
          input:
            file_path: "/path/to/small_file.go"
  # audit_check approves
  - node: audited_loop.audit_check
    output:
      message:
        role: assistant
        text: ""
      response_text: ""
      tool_calls:
        - id: call_1
          name: audit
          input:
            approved: true
            guidance: ""
  # execute_audit result
  - node: audited_loop.execute_audit
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_1
          content: '{"approved": true}'
      response_data:
        audit:
          approved: true
          guidance: ""
      thread_token_count: 500
  # execute_tools returns small result, token count stays below threshold
  - node: audited_loop.execute_tools
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_0
          content: "package main"
      thread_token_count: 600
  # Compact is skipped because thread_token_count (600) < compaction_threshold (185000)
  # Next iteration: main_agent responds with final answer
  - node: audited_loop.main_agent
    output:
      message:
        role: assistant
        text: "The file contains a simple Go package."
      response_text: "The file contains a simple Go package."
      tool_calls: []
  # audit_check approves final response
  - node: audited_loop.audit_check
    output:
      message:
        role: assistant
        text: ""
      response_text: ""
      tool_calls:
        - id: call_2
          name: audit
          input:
            approved: true
            guidance: ""
  - node: audited_loop.execute_audit
    output:
      message:
        role: tool
        text: ""
      tool_results:
        - tool_call_id: call_2
          content: '{"approved": true}'
      response_data:
        audit:
          approved: true
          guidance: ""
      thread_token_count: 700
expect:
  outcome: completed
  reached:
    - audited_loop
    - audited_loop.main_agent
    - audited_loop.audit_check
    - audited_loop.execute_audit
    - audited_loop.save_approved_response
    - audited_loop.execute_tools
  not_reached:
    - audited_loop.compact
