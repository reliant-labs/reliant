# Large Results Filtered: Big tool output goes through filter path
#
# Tests the context reduction mechanism for large results:
# 1. LLM calls tools
# 2. Tool results are large (> 4000 chars)
# 3. filter_results LLM call extracts relevant info
# 4. Filtered results are saved via save_filtered_results
# 5. LLM responds without tools, loop exits
#
# This verifies large outputs are compressed before being saved.

name: large_results_filtered
description: Large tool results go through LLM filtering before being saved

inputs:
  mode: "auto"

events:
  # Iteration 1: LLM calls a tool
  - node: agent_loop.call_llm
    type: llm_response
    text: "Let me search the codebase for error handling patterns."
    tool_calls:
      - name: grep
        input:
          pattern: "error"
          path: "/project/"

  # Large tool result (over 4000 chars)
  - node: agent_loop.execute_tools
    type: tool_result
    tool: grep
    output:
      result: "src/main.go:15: if err != nil { return err }\nsrc/main.go:23: if err != nil { log.Error(err) }\nsrc/handler.go:8: func handleError(err error) {\nsrc/handler.go:12: return fmt.Errorf(\"wrapped: %w\", err)\n... (many more lines)"
      total_result_chars: 5000  # Over 4000 threshold

  # Filter results LLM call
  - node: agent_loop.filter_results
    type: llm_response
    tool_calls:
      - name: filtered_results
        input:
          results:
            - tool_call_id: "call_0"
              name: "grep"
              filtered: true
              content: "Found error handling in main.go (lines 15, 23) and handler.go (lines 8, 12). Uses standard if err != nil pattern and wraps errors."
              is_error: false

  # Execute filter response tool
  - node: agent_loop.execute_filter
    type: tool_result
    tool: filtered_results
    output:
      results:
        - tool_call_id: "call_0"
          name: "grep"
          filtered: true
          content: "Found error handling in main.go (lines 15, 23) and handler.go (lines 8, 12). Uses standard if err != nil pattern and wraps errors."
          is_error: false

  # Iteration 2: LLM responds without tools
  - node: agent_loop.call_llm
    type: llm_response
    text: "The codebase uses standard Go error handling with the if err != nil pattern. Errors are wrapped in handler.go using fmt.Errorf."

expect:
  outcome: completed
  reached:
    - agent_loop
    - agent_loop.call_llm
    - agent_loop.execute_tools
    - agent_loop.filter_results  # Filter LLM called
    - agent_loop.execute_filter  # Filter response tool executed
    - agent_loop.save_filtered_results  # Filtered results saved
  not_reached:
    # Direct save path skipped for large results
    - agent_loop.save_tool_results
    - agent_loop.approval
    - agent_loop.compact
