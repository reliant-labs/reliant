# Synthesize path: Reviewer decides to combine best parts from multiple implementations
name: parallel_compete_synthesize
description: Reviewer chooses to synthesize best parts from multiple implementations
events:
  - node: improve_prompt
    output:
      message:
        role: assistant
        text: "Build a cache layer with TTL support"
      response_text: "Build a cache layer with TTL support"
      tool_calls: []
  
  - node: create_worktree_1
    output:
      id: "wt1"
      name: "b1"
      path: "/wt/1"
      branch: "b1"
      base_branch: "main"
      repo_id: "test"
      status: "created"
  - node: create_worktree_2
    output:
      id: "wt2"
      name: "b2"
      path: "/wt/2"
      branch: "b2"
      base_branch: "main"
      repo_id: "test"
      status: "created"
  - node: create_worktree_3
    output:
      id: "wt3"
      name: "b3"
      path: "/wt/3"
      branch: "b3"
      base_branch: "main"
      repo_id: "test"
      status: "created"
  
  - node: impl_1
    output:
      message:
        role: assistant
        text: "Created cache.go with excellent TTL implementation"
      response_text: "Created cache.go with excellent TTL implementation"
  
  - node: impl_2
    output:
      message:
        role: assistant
        text: "Created cache.go with great test coverage but basic TTL"
      response_text: "Created cache.go with great test coverage but basic TTL"
  
  - node: impl_3
    output:
      message:
        role: assistant
        text: "Created cache.go with good API design but minimal tests"
      response_text: "Created cache.go with good API design but minimal tests"
  
  # Reviewer chooses synthesize strategy
  - node: review
    output:
      message:
        role: assistant
        text: "Each implementation has unique strengths that should be combined."
      response_text: "Each implementation has unique strengths that should be combined."
      winner: 1
      strategy: "synthesize"
      confidence: 9
      rationale: "Candidate 1 has the best TTL implementation, Candidate 2 has the best tests, and Candidate 3 has the best API design."
      synthesis_instructions: |
        1. Use Candidate 1's cache.go as the base (best TTL logic)
        2. Copy Candidate 2's cache_test.go for test coverage
        3. Update the public API in cache.go to match Candidate 3's cleaner interface

  # Synthesizer agent combines the implementations
  - node: synthesizer
    output:
      message:
        role: assistant
        text: |
          Synthesis complete. I have:
          1. Used Candidate 1's TTL implementation as the base
          2. Added Candidate 2's comprehensive test suite
          3. Refactored the API to match Candidate 3's cleaner design
      response_text: |
        Synthesis complete. I have:
        1. Used Candidate 1's TTL implementation as the base
        2. Added Candidate 2's comprehensive test suite
        3. Refactored the API to match Candidate 3's cleaner design

expect:
  outcome: completed
  reached:
    - improve_prompt
    - save_improved_prompt
    - create_worktree_1
    - create_worktree_2
    - create_worktree_3
    - impl_1
    - impl_2
    - impl_3
    - review
    - synthesizer
    - apply_done
    - complete
  not_reached:
    - apply_winner
